---
layout: post
title: "Object Class"
categories: [ java_lang ]
---

### 자바 개발자 교양 1 편

Object 클래스를 들어가보면 가장 윗부분에 registerNatives 라는 것이 나온다. 
이것은 (OpenJDK의 구현에서) Object 클래스의 네이티브 함수를 등록하는 코드이다.
```java
private static native void registerNatives();
static {
    registerNatives();
}
```


클래스 객체는 클래스 계층의 루트입니다. 모든 클래스에는 상위 클래스로 Object가 있습니다. 배열을 포함한 모든 객체는 이 클래스의 메소드를 구현합니다.
새 개체를 생성합니다.

```java
public Object(){}
```

이 Object의 런타임 클래스를 반환합니다. 반환된 Class 개체는 표시된 클래스의 정적 동기화 메서드에 의해 잠긴 개체입니다.
실제 결과 유형은 Class<? 확장 |X|> 여기서 |X| getClass가 호출되는 표현식의 정적 유형의 삭제입니다. 예를 들어 이 코드 조각에는 캐스트가 필요하지 않습니다.
숫자 n = 0; 수업<? 확장 번호> c = n.getClass();
보고:
이 개체의 런타임 클래스를 나타내는 Class 개체입니다.

```java
@HotSpotIntrinsicCandidate
public final native Class<?> getClass();
```

개체에 대한 해시 코드 값을 반환합니다. 이 메소드는 java.util.HashMap에서 제공하는 것과 같은 해시 테이블의 이점을 위해 지원됩니다.
hashCode의 일반 계약은 다음과 같습니다.
Java 응용 프로그램을 실행하는 동안 동일한 개체에 대해 두 번 이상 호출될 때마다 hashCode 메서드는 개체에 대한 동등 비교에 사용된 정보가 수정되지 않는 한 일관되게 동일한 정수를 반환해야 합니다. 이 정수는 한 애플리케이션 실행에서 동일한 애플리케이션의 다른 실행까지 일관성을 유지할 필요가 없습니다.
equals(Object) 메서드에 따라 두 객체가 같으면 두 객체 각각에 대해 hashCode 메서드를 호출하면 동일한 정수 결과가 생성되어야 합니다.
equals(Object) 메서드에 따라 두 개체가 같지 않은 경우 두 개체 각각에 대해 hashCode 메서드를 호출하면 고유한 정수 결과가 생성되어야 하는 것은 아닙니다. 그러나 프로그래머는 같지 않은 개체에 대해 고유한 정수 결과를 생성하면 해시 테이블의 성능이 향상될 수 있음을 알고 있어야 합니다.
합리적으로 실용적인 한, 클래스 Object에 의해 정의된 hashCode 메서드는 고유한 개체에 대해 고유한 정수를 반환합니다. (hashCode는 특정 시점에서 객체의 메모리 주소의 일부 기능으로 구현되거나 구현되지 않을 수 있습니다.)
보고:
이 개체의 해시 코드 값입니다.
또한보십시오:
equals(객체), System.identityHashCode

```java
@HotSpotIntrinsicCandidate
public native int hashCode();
```

일부 다른 개체가 이 개체와 "동일한"지 여부를 나타냅니다.
equals 메소드는 null이 아닌 객체 참조에 대해 등가 관계를 구현합니다.
반사적입니다. null이 아닌 참조 값 x에 대해 x.equals(x)는 true를 반환해야 합니다.
대칭입니다. null이 아닌 참조 값 x 및 y에 대해 x.equals(y)는 y.equals(x)가 true를 반환하는 경우에만 true를 반환해야 합니다.
전이적입니다. null이 아닌 참조 값 x, y 및 z에 대해 x.equals(y)가 true를 반환하고 y.equals(z)가 true를 반환하면 x.equals(z)가 true를 반환해야 합니다.
일관성이 있습니다. null이 아닌 참조 값 x 및 y에 대해 x.equals(y)를 여러 번 호출하면 객체에 대한 같음 비교에 사용된 정보가 수정되지 않는 한 일관되게 true를 반환하거나 일관되게 false를 반환합니다.
null이 아닌 참조 값 x에 대해 x.equals(null)는 false를 반환해야 합니다.
클래스 Object에 대한 equals 메소드는 객체에 대해 가장 구별 가능한 등가 관계를 구현합니다. 즉, null이 아닌 참조 값 x 및 y에 대해 이 메서드는 x와 y가 동일한 개체를 참조하는 경우에만 true를 반환합니다(x == y의 값은 true임).
동일한 객체가 동일한 해시 코드를 가져야 함을 명시하는 hashCode 메소드에 대한 일반 계약을 유지하기 위해 일반적으로 이 메소드가 재정의될 때마다 hashCode 메소드를 재정의해야 합니다.
매개변수:
obj – 비교할 참조 개체입니다.
보고:
이 개체가 obj 인수와 같으면 true이고, 그렇지 않으면 false입니다. 그렇지 않으면 거짓.
또한보십시오:
hashCode(), java.util.HashMap

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

이 개체의 복사본을 만들고 반환합니다. "복사"의 정확한 의미는 개체의 클래스에 따라 다를 수 있습니다. 일반적인 의도는 모든 객체 x에 대해 표현식이 다음과 같다는 것입니다.
       x.clone() != x
참이고 그 표현은 다음과 같습니다.
       x.clone().getClass() == x.getClass()
사실이지만 이것이 절대적인 요구 사항은 아닙니다. 일반적으로 다음과 같은 경우입니다.
       x.clone().equals(x)
이것은 사실이지만 절대적인 요구 사항은 아닙니다.
관례에 따라 반환된 객체는 super.clone을 호출하여 얻어야 합니다. 클래스와 모든 상위 클래스(Object 제외)가 이 규칙을 따르는 경우 x.clone().getClass() == x.getClass()가 됩니다.
규칙에 따라 이 메서드에서 반환된 개체는 이 개체(복제 중인 개체)와 독립적이어야 합니다. 이러한 독립성을 달성하기 위해 super.clone이 반환한 객체를 반환하기 전에 객체의 하나 이상의 필드를 수정해야 할 수 있습니다. 일반적으로 이것은 복제되는 개체의 내부 "심층 구조"를 구성하는 변경 가능한 개체를 복사하고 이러한 개체에 대한 참조를 복사본에 대한 참조로 대체하는 것을 의미합니다. 클래스에 기본 필드 또는 변경할 수 없는 개체에 대한 참조만 포함된 경우 일반적으로 super.clone에서 반환한 개체의 필드를 수정할 필요가 없습니다.
Object 클래스에 대한 메소드 복제는 특정 복제 작업을 수행합니다. 먼저 이 개체의 클래스가 Cloneable 인터페이스를 구현하지 않으면 CloneNotSupportedException이 throw됩니다. 모든 배열은 인터페이스 Cloneable을 구현하는 것으로 간주되며 배열 유형 T[]의 복제 메소드의 반환 유형은 T[]이며 여기서 T는 임의의 참조 또는 기본 유형입니다. 그렇지 않으면 이 메서드는 이 개체의 클래스에 대한 새 인스턴스를 만들고 할당에 의한 것처럼 이 개체의 해당 필드 내용을 정확히 사용하여 모든 필드를 초기화합니다. 필드의 내용 자체는 복제되지 않습니다. 따라서 이 메서드는 "깊은 복사" 작업이 아니라 이 개체의 "얕은 복사"를 수행합니다.
Object 클래스는 자체적으로 Cloneable 인터페이스를 구현하지 않으므로 클래스가 Object인 개체에서 복제 메서드를 호출하면 런타임에 예외가 throw됩니다.
보고:
이 인스턴스의 클론입니다.
던짐:
CloneNotSupportedException – 개체의 클래스가 Cloneable 인터페이스를 지원하지 않는 경우. 복제 메서드를 재정의하는 하위 클래스는 인스턴스를 복제할 수 없음을 나타내기 위해 이 예외를 throw할 수도 있습니다.
또한보십시오:
복제 가능

```java
@HotSpotIntrinsicCandidate
protected native Object clone() throws CloneNotSupportedException;
```

개체의 문자열 표현을 반환합니다. 일반적으로 toString 메서드는 이 객체를 "텍스트로 나타내는" 문자열을 반환합니다. 결과는 간결하지만 사람이 읽기 쉬운 정보를 제공해야 합니다. 모든 하위 클래스가 이 메서드를 재정의하는 것이 좋습니다.
Object 클래스에 대한 toString 메소드는 객체가 인스턴스인 클래스의 이름, at-sign 문자 `@' 및 객체의 해시 코드의 부호 없는 16진수 표현으로 구성된 문자열을 반환합니다. 즉, 이 메서드는 다음 값과 같은 문자열을 반환합니다.
        getClass().getName() + '@' + Integer.toHexString(hashCode())
       
보고:
객체의 문자열 표현.

```java
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

1251 / 5000
번역 결과
이 개체의 모니터에서 대기 중인 단일 스레드를 깨웁니다. 이 개체에서 대기 중인 스레드가 있으면 그 중 하나가 깨어나도록 선택됩니다. 선택은 임의적이며 구현의 재량에 따라 발생합니다. 스레드는 대기 메서드 중 하나를 호출하여 개체의 모니터를 기다립니다.
깨어난 스레드는 현재 스레드가 이 개체에 대한 잠금을 해제할 때까지 진행할 수 없습니다. 깨어난 스레드는 이 개체에서 동기화하기 위해 적극적으로 경쟁할 수 있는 다른 스레드와 일반적인 방식으로 경쟁합니다. 예를 들어, 깨어난 스레드는 이 개체를 잠그는 다음 스레드가 되는 데 있어 신뢰할 수 있는 권한이나 단점을 갖지 않습니다.
이 메서드는 이 개체의 모니터 소유자인 스레드에서만 호출해야 합니다. 스레드는 다음 세 가지 방법 중 하나로 개체 모니터의 소유자가 됩니다.
해당 개체의 동기화된 인스턴스 메서드를 실행합니다.
개체에서 동기화하는 동기화된 문의 본문을 실행합니다.
클래스 유형의 개체의 경우 해당 클래스의 동기화된 정적 메서드를 실행합니다.
한 번에 하나의 스레드만 개체의 모니터를 소유할 수 있습니다.
던짐:
IllegalMonitorStateException – 현재 스레드가 이 개체의 모니터 소유자가 아닌 경우.
또한보십시오:
모든 알림(), 대기()

```java
@HotSpotIntrinsicCandidate
public final native void notify();
```

일반적으로 알림을 받거나 중단되어 현재 스레드가 깨어날 때까지 대기하도록 합니다.
모든 면에서 이 메서드는 wait(0L, 0)이 호출된 것처럼 동작합니다. 자세한 내용은 wait(long, int) 메서드의 사양을 참조하세요.
던짐:
IllegalMonitorStateException - 현재 스레드가 개체 모니터의 소유자가 아닌 경우
InterruptedException – 현재 스레드가 대기하기 전이나 대기하는 동안 스레드가 현재 스레드를 인터럽트한 경우. 이 예외가 발생하면 현재 스레드의 중단된 상태가 지워집니다.
또한보십시오:
notify(), notifyAll(), wait(long), wait(long, int)

```java
public final void wait() throws InterruptedException {
    wait(0L);
}
```

현재 스레드가 일반적으로 알림을 받거나 중단되거나 특정 시간이 경과할 때까지 깨어날 때까지 기다리게 합니다.
현재 스레드는 이 개체의 모니터 잠금을 소유해야 합니다. 스레드가 모니터 잠금의 소유자가 될 수 있는 방법에 대한 설명은 notify 메소드를 참조하십시오.
이 메서드를 사용하면 현재 스레드(여기서 T라고 함)가 이 개체에 대한 대기 집합에 자신을 배치한 다음 이 개체에 대한 모든 동기화 클레임을 포기합니다. 이 개체에 대한 잠금만 해제됩니다. 현재 스레드가 동기화될 수 있는 다른 모든 개체는 스레드가 대기하는 동안 잠긴 상태로 유지됩니다.
그런 다음 스레드 T는 스레드 스케줄링 목적을 위해 비활성화되고 다음 중 하나가 발생할 때까지 휴면 상태가 됩니다.
어떤 다른 쓰레드는 이 객체에 대한 notify 메소드를 호출하고 쓰레드 T는 깨울 쓰레드로 임의로 선택된다.
일부 다른 스레드는 이 개체에 대한 notifyAll 메서드를 호출합니다.
다른 스레드가 스레드 T를 인터럽트합니다.
지정된 실제 시간이 어느 정도 경과했습니다. 나노초 단위의 실시간 시간은 1000000 * timeoutMillis + nanos 식으로 표시됩니다. timeoutMillis 및 nanos가 모두 0이면 실시간은 고려되지 않고 스레드는 다른 원인 중 하나로 깨어날 때까지 기다립니다.
스레드 T가 가짜로 깨어났습니다. (아래 참조.)
그런 다음 스레드 T는 이 개체에 대한 대기 세트에서 제거되고 스레드 스케줄링을 위해 다시 활성화됩니다. 개체에 대한 동기화 권한을 얻기 위해 다른 스레드와 일반적인 방식으로 경쟁합니다. 개체에 대한 제어를 다시 얻으면 개체에 대한 모든 동기화 클레임이 현상 유지, 즉 대기 메서드가 호출된 시점의 상황으로 복원됩니다. 그런 다음 스레드 T는 wait 메서드 호출에서 반환됩니다. 따라서 wait 메서드에서 반환될 때 개체와 스레드 T의 동기화 상태는 wait 메서드가 호출되었을 때와 정확히 동일합니다.
스레드는 알림을 받거나 중단되거나 시간 초과되지 않고 깨어날 수 있습니다. 이를 가짜 깨우기라고 합니다. 이것은 실제로는 거의 발생하지 않지만 응용 프로그램은 스레드를 깨워야 하는 조건을 테스트하고 조건이 충족되지 않으면 계속 대기하여 이를 방지해야 합니다. 아래 예를 참조하십시오.
이 주제에 대한 자세한 내용은 Brian Goetz 및 기타 사용자의 Java Concurrency in Practice(Addison-Wesley, 2006)의 섹션 14.2, "조건 큐" 또는 Joshua Bloch의 Effective Java, Second Edition(Addison-Wesley, 2008)의 항목 69를 참조하십시오. ).
현재 스레드가 대기 중이거나 대기 중인 동안 스레드에 의해 인터럽트되면 InterruptedException이 발생합니다. 이 예외가 발생하면 현재 스레드의 중단된 상태가 지워집니다. 이 예외는 위에서 설명한 대로 이 개체의 잠금 상태가 복원될 때까지 throw되지 않습니다.
매개변수:
timeoutMillis – 최대 대기 시간(밀리초)
nanos – 0-999999 범위의 추가 시간(나노초)
던짐:
IllegalArgumentException – timeoutMillis가 음수이거나 나노 값이 범위를 벗어난 경우
IllegalMonitorStateException - 현재 스레드가 개체 모니터의 소유자가 아닌 경우
InterruptedException - 현재 스레드가 대기하기 전이나 대기하는 동안 스레드가 현재 스레드를 인터럽트한 경우. 이 예외가 발생하면 현재 스레드의 중단된 상태가 지워집니다.
API 참고:
대기에 대한 권장 접근 방식은 아래 예와 같이 대기 호출 주변의 while 루프에서 대기 중인 조건을 확인하는 것입니다. 무엇보다도 이 접근 방식은 가짜 깨우기로 인해 발생할 수 있는 문제를 방지합니다.
 
     동기화된(obj) {
         while (<조건이 유지되지 않음> 및 <시간 초과가 초과되지 않음>) {
             긴 timeoutMillis = ... ; // 타임아웃 값 재계산
             정수 나노 = ... ;
             obj.wait(timeoutMillis, nanos);
         }
         ... // 조건 또는 시간 초과에 적합한 작업 수행
     }
 
또한보십시오:
알림(), 알림 모두(), 대기(), 대기(긴)

```java
public final void wait(long timeoutMillis, int nanos) throws InterruptedException {
    if (timeoutMillis < 0) {
        throw new IllegalArgumentException("timeoutMillis value is negative");
    }

    if (nanos < 0 || nanos > 999999) {
        throw new IllegalArgumentException(
                            "nanosecond timeout value out of range");
    }

    if (nanos > 0) {
        timeoutMillis++;
    }

    wait(timeoutMillis);
}
```

가비지 수집에서 개체에 대한 참조가 더 이상 없다고 결정할 때 개체의 가비지 수집기에 의해 호출됩니다. 하위 클래스는 시스템 리소스를 삭제하거나 다른 정리를 수행하기 위해 finalize 메서드를 재정의합니다.
finalize의 일반 계약은 Java™ 가상 머신이 조치의 결과를 제외하고 아직 죽지 않은 스레드에서 이 객체에 액세스할 수 있는 수단이 더 이상 없다고 판단한 경우 호출된다는 것입니다. 완료될 준비가 된 다른 객체 또는 클래스의 종료에 의해 취해집니다. finalize 메서드는 이 개체를 다른 스레드에서 다시 사용할 수 있도록 하는 것을 포함하여 모든 작업을 수행할 수 있습니다. 그러나 finalize의 일반적인 목적은 개체를 취소할 수 없게 버리기 전에 정리 작업을 수행하는 것입니다. 예를 들어 입력/출력 연결을 나타내는 개체의 finalize 메서드는 개체가 영구적으로 삭제되기 전에 연결을 끊기 위해 명시적 I/O 트랜잭션을 수행할 수 있습니다.
Object 클래스의 finalize 메서드는 특별한 작업을 수행하지 않습니다. 단순히 정상적으로 반환됩니다. Object의 하위 클래스는 이 정의를 재정의할 수 있습니다.
Java 프로그래밍 언어는 주어진 객체에 대해 어떤 스레드가 finalize 메서드를 호출할지 보장하지 않습니다. 그러나 finalize를 호출하는 스레드는 finalize가 호출될 때 사용자가 볼 수 있는 동기화 잠금을 보유하지 않을 것임을 보장합니다. finalize 메서드에 의해 포착되지 않은 예외가 발생하면 예외가 무시되고 해당 개체의 종료가 종료됩니다.
객체에 대해 finalize 메서드가 호출된 후 가능한 작업을 포함하여 아직 죽지 않은 스레드에서 이 객체에 액세스할 수 있는 수단이 더 이상 없다고 Java 가상 머신이 다시 결정할 때까지 추가 작업이 수행되지 않습니다. 완료될 준비가 된 다른 객체 또는 클래스에 의해 객체가 폐기될 수 있습니다.
finalize 메소드는 주어진 객체에 대해 JVM(Java Virtual Machine)에 의해 두 번 이상 호출되지 않습니다.
finalize 메서드에서 예외가 발생하면 이 개체의 종료가 중지되지만 그렇지 않으면 무시됩니다.
더 이상 사용되지 않음
종료 메커니즘은 본질적으로 문제가 있습니다. 마무리는 성능 문제, 교착 상태 및 중단으로 이어질 수 있습니다. 종료자의 오류는 리소스 누수로 이어질 수 있습니다. 더 이상 필요하지 않은 경우 종료를 취소할 방법이 없습니다. 다른 개체의 메서드를 종료하기 위한 호출 간에 순서가 지정되지 않습니다. 또한 완료 시점에 대한 보장은 없습니다. finalize 메서드는 무기한 지연된 경우에만 종료 가능한 개체에 대해 호출될 수 있습니다. 인스턴스가 힙이 아닌 리소스를 보유하는 클래스는 해당 리소스를 명시적으로 해제할 수 있는 메서드를 제공해야 하며 적절한 경우 AutoCloseable도 구현해야 합니다. ref.Cleaner 및 ref.PhantomReference는 개체에 연결할 수 없을 때 리소스를 해제하는 보다 유연하고 효율적인 방법을 제공합니다.
던짐:
Throwable – 이 메서드에 의해 발생한 예외
API 참고:
힙이 아닌 리소스를 포함하는 클래스에는 이러한 리소스를 정리할 수 있는 많은 옵션이 있습니다. 클래스는 각 인스턴스의 수명이 포함된 리소스의 수명보다 긴지 확인해야 합니다. ref.Reference.reachabilityFence는 객체에 포함된 리소스가 사용 중인 동안 객체에 도달 가능한 상태로 유지되도록 하는 데 사용할 수 있습니다.
서브클래스는 인스턴스가 수집되기 전에 정리해야 하는 힙이 아닌 리소스를 서브클래스에 포함하지 않는 한 finalize 메서드를 재정의하지 않아야 합니다. 종료자 호출은 생성자와 달리 자동으로 연결되지 않습니다. 하위 클래스가 finalize를 재정의하는 경우 상위 클래스 종료자를 명시적으로 호출해야 합니다. 종료 체인을 조기에 종료하는 예외를 방지하려면 하위 클래스에서 try-finally 블록을 사용하여 super.finalize()가 항상 호출되도록 해야 합니다. 예를 들어,
      @우세하다
     protected void finalize() throwable {
         노력하다 {
             ... // 하위 클래스 상태 정리
         } 마지막으로 {
             super.finalize();
         }
     }
 
또한보십시오:
ref.WeakReference, ref.PhantomReference

```java
@Deprecated(since="9")
protected void finalize() throws Throwable {}
```